@ filename: int_director.s
@
@ Interrupt handler for UART4, GPIO1_31 button, eventually a timer
@
@ Written by: James Ross

.text
.global _int_director
_int_director:
@ Interupt definitions
.equ INTC_BASE,           0x48200000 @ INCPS               	  Base Address
.equ INTC_CONTROL,        0x48       @ INTC_CONTROL        	  register offset
.equ INTC_CONFIG,         0x10       @ INTC_SYSCONFIG      	  register offset
.equ INTC_MIR_CLEAR2,     0xC8       @ INTC_MIR_CLEAR2     	  register offset
.equ INTC_MIR_CLEAR3,     0xE8       @ INTC_MIR_CLEAR3     	  register offset
.equ INTC_MIR_SET3,       0xEC       @ INTC_MIR_SET3       	  register offset
.equ INTC_PENDING_IRQ3,   0xF8       @ INTC_PENDING_IRQ       register offset
.equ GPIOINT1A,           0x4        @ GPIOINT1A in MIR1/IPI3 Mask

@ GPIO definitions
.equ GPIO1_BASE,		  0x4804C000  @ GPIO1 				Base Address
.equ GPIO_IRQ_STAT_0,	  0x2C	  	  @ GPIO_IRQSTATUS_0 	register offset
.equ GPIO_31,			  0x80000000  @ GPIO_31 raised bit	Mask

@ UART definitions
.equ UART4_BASE,    	  0x481A8000 @ UART4          	      Base Address
.equ UART_LSR,			  0x14		 @ Line control reg		  register offset
.equ UART_MODEMCTRL,      0x10 	     @ Modem CTRL 			  register offset
.equ UART_MSR,			  0x18		 @ Modem Status Reg 	  register offset
.equ UART_IIR,     		  0x8	 	 @ Interrupt ID		  	  register offset
.equ UART_IER,     	      0x4	 	 @ IER_UART, Int EN       register offset
.equ CTS_CHECK, 		  0x10		 @ Bit 4 used in MSR	  Mask
.equ THR_CHECK,			  0x20       @ Bit 5 used in LSR	  Mask
.equ UART4INT,			  0x2000     @ UART4INT in MIR1/IPI1  Mask
.equ THR_CLR,			  0xFFFE 	 @ And Clears bit0 in IER Mask

@ register assignment definitions
intcBase  .req R10
gpio1Base .req R9
uart4Base .req R8

@******************************* start _int_director ***************************
	STMFD SP!, {R0-R12, LR}
	LDR intcBase, =INTC_BASE
	
UART4_IRQ_TST:
	@ Check to see if UART4 triggered the interrupt
	LDR R0, [intcBase, #INTC_PENDING_IRQ1]
	TST R0, #UART4INT
	BEQ BTN_IRQ_TST
	
	@ Check IIR_UART to see if one of the UART interrupts occured
	LDR uart4Base, =UART4_BASE
	LDR R0, [uart4Base, #IIR_UART]
	TST R0, #0x1
	BEQ END_SVC

TALKER_SVC:
	@ See if CTS# is asserted
	LDR R0, [uart4Base, #UART_MSR]
	TST R0, #CTS_CHECK
	BNE YES_CTS_THR_TST

NO_CTS_THR_TST:  @ CTS# not asserted low
	@ Check if THR is empty
	LDR R0, [uart3Base, #UART_LSR]
	TST R0, #THR_CHECK
	BEQ END_SVC  @ CTS# not asserted, THR not empty, return
	
	@ THR is empty, CTS# not asserted, Mask TRR interrupt
	LDR R0, [uart4Base, #UART_IER]
	MOV R1, #THR_CLR
	AND R1, R1, R0		@ Clear lowest bit, THR interrupt
	STR [R1, R0] 		@ Store result with lowest bit clear 
	
	@ Return to wait loop waiting for CTS# to be asserted
	B END_SVC
	
YES_CTS_THR_TST: @ CTS# asserted low
	@ Check if THR is empty
	LDR R0, [uart3Base, #UART_LSR]
	TST R0, #THR_CHECK
	BEQ END_SVC  @ THR not empty, return to wait for THR
	
SEND_CHAR:

		

	@***********************************************************************
	@ TODO: Do a check to make sure this is not being done on last character
	@***********************************************************************
	@ Set interrupt to generate is CTS# changes state and if Transmit Holding 
	@ Regiser (THR) is empty IF more characters need to be sent.
	MOV R4, #SET_UART_IER
	STR R4, [uart4Base, #UART_IER]
		
BTN_IRQ_TST:
	@ Check if INT occured from GPIO1
	LDR R0, [intcBase, #INTC_PENDING_IRQ3]
	TST R0, #GPIOINT1A
	@BEQ TIMER_IRQ_TST   @ place holder for future timer
	BEQ END_SVC
	
	@ Check if the button on GPIO_31 triggered the interrupt
	LDR gpio1Base, =GPIO1_BASE
	LDR R0, [gpio1Base, #GPIO_IRQ_STAT_0]
	TST R0, #GPIO_31
	BEQ SVC_BUTTON @ If GPIO_31 does not have a pending INT, return

SVC_BUTTON:
	@ ***********************************************************************
	@ TODO: Set a flag or use a value that prevents the button being pressed
	@		while the message is being sent to be spoken
	@ **********************************************************************

	@ Disable GPIO1_31 intrrupt requests and INTC interrupt requests
	MOV R0, #GPIO_31	
	STR R0, [gpio1Base, #GPIO_IRQ_STAT_0] @ 1 at bit 31 of GPIO_IRQ_STAT_0

	@ TODO: Pretty sure this should be only one on the button press. Disabled
	@ 		upon the last message being sent, so next button press will set it
	@		again.
	@ Set interrupt to generate is CTS# changes state and if Transmit Holding 
	@ Regiser (THR) is empty
	MOV R4, #SET_UART_IER
	STR R4, [uart4Base, #UART_IER]

END_SVC:
	@ Disable NEWIRQA bit so processor can respond to IRQ
	MOV R0, #0x1
	STR R0, [intc_baseAddr, #INTC_CONTROL]	

	LDMFD SP!, {R0-R12, LR}
	SUBS PC, LR, #0x4
.end
@****************** EOF ****************